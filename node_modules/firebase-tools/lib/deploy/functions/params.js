"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveParams = exports.resolveBoolean = exports.resolveString = exports.resolveInt = void 0;
const logger_1 = require("../../logger");
const error_1 = require("../../error");
const prompt_1 = require("../../prompt");
const functional_1 = require("../../functional");
function isCEL(expr) {
    return typeof expr === "string" && expr.includes("{{") && expr.includes("}}");
}
function dependenciesCEL(expr) {
    const deps = [];
    const paramCapture = /{{ params\.(\w+) }}/g;
    let match;
    while ((match = paramCapture.exec(expr)) != null) {
        deps.push(match[1]);
    }
    return deps;
}
function resolveInt(from, paramValues) {
    if (typeof from === "number") {
        return from;
    }
    const match = /\A{{ params\.(\w+) }}\z/.exec(from);
    if (!match) {
        throw new error_1.FirebaseError("CEL evaluation of expression '" + from + "' not yet supported");
    }
    const referencedParamValue = paramValues[match[1]];
    if (typeof referencedParamValue !== "number") {
        throw new error_1.FirebaseError("Referenced numeric parameter '" +
            match +
            "' resolved to non-number value " +
            referencedParamValue);
    }
    return referencedParamValue;
}
exports.resolveInt = resolveInt;
function resolveString(from, paramValues) {
    if (!isCEL(from)) {
        return from;
    }
    let output = from;
    const paramCapture = /{{ params\.(\w+) }}/g;
    let match;
    while ((match = paramCapture.exec(from)) != null) {
        const referencedParamValue = paramValues[match[1]];
        if (typeof referencedParamValue !== "string") {
            throw new error_1.FirebaseError("Referenced string parameter '" +
                match[1] +
                "' resolved to non-string value " +
                referencedParamValue);
        }
        output = output.replace(`{{ params.${match[1]} }}`, referencedParamValue);
    }
    if (isCEL(output)) {
        throw new error_1.FirebaseError("CEL evaluation of non-identity expression '" + from + "' not yet supported");
    }
    return output;
}
exports.resolveString = resolveString;
function resolveBoolean(from, paramValues) {
    if (typeof from === "string" && /{{ params\.(\w+) }}/.test(from)) {
        const match = /{{ params\.(\w+) }}/.exec(from);
        const referencedParamValue = paramValues[match[1]];
        if (typeof referencedParamValue !== "boolean") {
            throw new error_1.FirebaseError("Referenced boolean parameter '" +
                match +
                "' resolved to non-boolean value " +
                referencedParamValue);
        }
        return referencedParamValue;
    }
    else if (typeof from === "string") {
        throw new error_1.FirebaseError("CEL evaluation of expression '" + from + "' not yet supported");
    }
    return from;
}
exports.resolveBoolean = resolveBoolean;
function resolveDefaultCEL(type, expr, currentEnv) {
    const deps = dependenciesCEL(expr);
    const allDepsFound = deps.every((dep) => !!currentEnv[dep]);
    if (!allDepsFound) {
        throw new error_1.FirebaseError("Build specified parameter with un-resolvable default value " +
            expr +
            "; dependencies missing.");
    }
    switch (type) {
        case "string":
            return resolveString(expr, currentEnv);
        case "int":
            return resolveInt(expr, currentEnv);
        default:
            throw new error_1.FirebaseError("Build specified parameter with default " + expr + " of unsupported type");
    }
}
function canSatisfyParam(param, value) {
    if (param.type === "string") {
        return typeof value === "string";
    }
    else if (param.type === "int") {
        return typeof value === "number" && Number.isInteger(value);
    }
    (0, functional_1.assertExhaustive)(param);
}
async function resolveParams(params, projectId, userEnvs) {
    const paramValues = {};
    const [provided, outstanding] = (0, functional_1.partition)(params, (param) => {
        return {}.hasOwnProperty.call(userEnvs, param.param);
    });
    for (const param of provided) {
        if (!canSatisfyParam(param, userEnvs[param.param])) {
            throw new error_1.FirebaseError("Parameter " +
                param.param +
                " resolved to value from dotenv files " +
                userEnvs[param.param] +
                " of wrong type");
        }
        paramValues[param.param] = userEnvs[param.param];
    }
    for (const param of outstanding) {
        let paramDefault = param.default;
        if (paramDefault && isCEL(paramDefault)) {
            paramDefault = resolveDefaultCEL(param.type, paramDefault, paramValues);
        }
        if (paramDefault && !canSatisfyParam(param, paramDefault)) {
            throw new error_1.FirebaseError("Parameter " + param.param + " has default value " + paramDefault + " of wrong type");
        }
        paramValues[param.param] = await promptParam(param, paramDefault);
    }
    return paramValues;
}
exports.resolveParams = resolveParams;
async function promptParam(param, resolvedDefault) {
    if (param.type === "string") {
        return promptStringParam(param, resolvedDefault);
    }
    else if (param.type === "int") {
        return promptIntParam(param, resolvedDefault);
    }
    (0, functional_1.assertExhaustive)(param);
}
async function promptStringParam(param, resolvedDefault) {
    if (!param.input) {
        const defaultToText = { type: "text", text: {} };
        param.input = defaultToText;
    }
    switch (param.input.type) {
        case "select":
            throw new error_1.FirebaseError("Build specified string parameter " + param.param + " with unsupported input type 'select'");
        case "text":
        default:
            let prompt = `Enter a value for ${param.label || param.param}`;
            if (param.description) {
                prompt += ` \n(${param.description})`;
            }
            return await (0, prompt_1.promptOnce)({
                name: param.param,
                type: "input",
                default: resolvedDefault,
                message: prompt,
            });
    }
}
async function promptIntParam(param, resolvedDefault) {
    if (!param.input) {
        const defaultToText = { type: "text", text: {} };
        param.input = defaultToText;
    }
    switch (param.input.type) {
        case "select":
            throw new error_1.FirebaseError("Build specified int parameter " + param.param + " with unsupported input type 'select'");
        case "text":
        default:
            let prompt = `Enter a value for ${param.label || param.param}`;
            if (param.description) {
                prompt += ` \n(${param.description})`;
            }
            let res;
            while (true) {
                res = await (0, prompt_1.promptOnce)({
                    name: param.param,
                    type: "number",
                    default: resolvedDefault,
                    message: prompt,
                });
                if (Number.isInteger(res)) {
                    return res;
                }
                logger_1.logger.error(`${param.label || param.param} must be an integer; retrying...`);
            }
    }
}
